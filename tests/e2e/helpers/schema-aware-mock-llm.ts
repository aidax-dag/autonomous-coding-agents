/**
 * Schema-Aware Mock LLM Client
 *
 * ILLMClient implementation that returns Zod-valid JSON for each agent/skill type
 * based on system prompt keywords. Designed for E2E testing of the executor pipeline:
 *   MockLLM -> Adapter.parseResponse -> Zod validation -> Agent/Skill result
 *
 * @module tests/e2e/helpers
 */

import type {
  ILLMClient,
  LLMMessage,
  LLMCompletionOptions,
  LLMCompletionResult,
  LLMStreamCallback,
} from '@/shared/llm';

// ============================================================================
// Call Recording
// ============================================================================

export interface MockLLMCall {
  messages: LLMMessage[];
  options?: LLMCompletionOptions;
  timestamp: number;
}

// ============================================================================
// Error Simulation
// ============================================================================

export interface MockLLMErrorConfig {
  /** Fail on the Nth call (1-indexed). 0 = never fail. */
  errorOnNthCall?: number;
  /** Type of error to simulate */
  errorType?: 'parse' | 'timeout' | 'empty';
}

// ============================================================================
// Response Map (system prompt keyword -> valid JSON)
// ============================================================================

/** Valid PlanningOutput */
const planningResponse = {
  title: 'E2E Test Plan',
  summary: 'A plan generated by mock LLM for E2E testing',
  tasks: [
    {
      title: 'Implement feature module',
      type: 'feature',
      targetTeam: 'development',
      description: 'Create the core feature module',
      estimatedEffort: 'medium',
    },
    {
      title: 'Write unit tests',
      type: 'test',
      targetTeam: 'qa',
      description: 'Add unit tests for the feature',
      dependencies: ['Implement feature module'],
      estimatedEffort: 'small',
    },
  ],
  risks: ['Tight timeline'],
  assumptions: ['API contract is stable'],
};

/** Valid DevelopmentOutput */
const developmentResponse = {
  summary: 'Implemented the requested feature',
  filesModified: [
    { path: 'src/feature.ts', action: 'created', description: 'New feature module' },
    { path: 'src/index.ts', action: 'modified', description: 'Added export' },
  ],
  codeChanges: [
    {
      file: 'src/feature.ts',
      language: 'typescript',
      newCode: 'export function feature() { return true; }',
      explanation: 'Core feature function',
    },
  ],
  tests: ['feature.test.ts'],
  reviewNotes: ['Follows existing patterns'],
};

/** Valid QAOutput (test variant) */
const qaResponse = {
  summary: 'All tests passed successfully',
  testResults: {
    total: 5,
    passed: 5,
    failed: 0,
    skipped: 0,
    tests: [
      { name: 'should create feature', status: 'passed', duration: 10 },
      { name: 'should handle edge case', status: 'passed', duration: 15 },
    ],
  },
  coverage: { lines: 85, branches: 78, functions: 90, statements: 83 },
  qualityScore: 88,
  recommendations: ['Add integration tests'],
  approved: true,
  reason: 'All checks passed',
};

/** Valid ArchitectureOutput */
const architectureResponse = {
  components: [
    { name: 'AuthModule', responsibility: 'User authentication', dependencies: ['UserStore'] },
    { name: 'UserStore', responsibility: 'User data persistence', dependencies: [] },
  ],
  patterns: ['Repository Pattern', 'Dependency Injection'],
  tradeoffs: [
    { option: 'Monolith', pros: ['Simple deployment'], cons: ['Hard to scale'] },
  ],
  recommendation: 'Use modular monolith with clear boundaries',
};

/** Valid SecurityOutput */
const securityResponse = {
  summary: 'No critical vulnerabilities found',
  findings: [
    {
      severity: 'medium',
      category: 'input-validation',
      location: 'src/api/handler.ts:42',
      description: 'Missing input sanitization',
      recommendation: 'Add input validation middleware',
    },
  ],
  riskScore: 25,
  complianceStatus: 'partial',
  recommendations: ['Add CSP headers', 'Enable CORS restrictions'],
};

/** Valid DebuggingOutput (agent variant) */
const debuggingAgentResponse = {
  rootCause: 'Null reference in user lookup',
  hypotheses: [
    { description: 'Missing null check', confidence: 0.9, verified: true },
    { description: 'Race condition', confidence: 0.3, verified: false },
  ],
  evidence: [
    { source: 'stack trace', description: 'TypeError at line 42', relevance: 'high' },
  ],
  suggestedFix: 'Add null check before accessing user.name',
  nextSteps: ['Add regression test'],
};

/** Valid DocumentationOutput (agent variant) */
const documentationAgentResponse = {
  sections: [
    { title: 'Overview', content: 'Module overview content', type: 'overview' },
    { title: 'API Reference', content: 'Function signatures', type: 'api' },
  ],
  summary: 'Generated documentation for 2 modules',
  format: 'markdown',
  coveredFiles: ['src/feature.ts'],
};

/** Valid ExplorationOutput */
const explorationResponse = {
  files: [
    { path: 'src/feature.ts', type: 'typescript', size: 1024 },
    { path: 'src/utils.ts', type: 'typescript', size: 512 },
  ],
  symbols: [
    { name: 'feature', type: 'function', file: 'src/feature.ts', exported: true },
  ],
  patterns: ['Factory Pattern'],
  summary: 'Found 2 relevant files with factory pattern usage',
  dependencies: [
    { source: 'src/feature.ts', target: 'src/utils.ts', type: 'import' },
  ],
};

/** Valid IntegrationOutput */
const integrationResponse = {
  connections: [
    { source: 'API', target: 'Database', status: 'connected', protocol: 'TCP', latency: 5 },
  ],
  issues: [
    { severity: 'warning', component: 'Cache', description: 'Cache miss rate high', suggestion: 'Increase TTL' },
  ],
  coverage: 82,
  healthStatus: 'healthy',
  summary: 'Integration points are functioning correctly',
};

/** Valid TestGenerationOutput */
const testGenerationResponse = {
  summary: 'Generated 3 unit tests',
  tests: [
    {
      name: 'should return true for valid input',
      type: 'unit',
      code: 'test("should return true", () => { expect(fn()).toBe(true); })',
      target: 'feature()',
      filePath: 'tests/feature.test.ts',
    },
  ],
  totalGenerated: 3,
  estimatedCoverage: { functions: 80, branches: 70, lines: 75 },
  manualTestRecommendations: ['Test with real database'],
};

/** Valid DeepReviewOutput */
const deepReviewResponse = {
  summary: 'Code quality is generally good with minor issues',
  findings: [
    {
      type: 'maintainability',
      severity: 'minor',
      category: 'naming',
      message: 'Variable name too short',
      file: 'src/feature.ts',
      lineStart: 10,
      lineEnd: 10,
      suggestedFix: 'Rename to descriptive name',
    },
  ],
  metrics: { complexity: 20, maintainability: 85, testability: 80, security: 90, overall: 82 },
  approved: true,
  reason: 'Code meets quality standards',
  actionItems: ['Improve variable naming'],
};

/** Valid RefactoringOutput */
const refactoringResponse = {
  summary: 'Found 1 refactoring opportunity',
  suggestions: [
    {
      type: 'extract-method',
      priority: 'medium',
      target: { file: 'src/feature.ts', lineStart: 15, lineEnd: 30, symbolName: 'processData' },
      reason: 'Method too long',
      description: 'Extract validation logic into separate method',
      effort: 'easy',
      impact: 'localized',
    },
  ],
  technicalDebtScore: 25,
  codeHealth: { duplications: 10, complexity: 30, coupling: 20, cohesion: 80 },
  prioritizedOrder: ['Extract validation logic'],
};

/** Valid SecurityScanSkillOutput */
const securityScanSkillResponse = {
  findings: [
    { file: 'src/api.ts', line: 42, severity: 'medium', category: 'xss', message: 'Unescaped output' },
  ],
  summary: 'Found 1 medium severity issue',
  score: 75,
};

/** Valid DebuggingSkillOutput */
const debuggingSkillResponse = {
  rootCause: 'Unhandled promise rejection',
  hypothesis: ['Missing await keyword', 'Error not caught'],
  suggestedFixes: [
    { description: 'Add await before async call', file: 'src/service.ts', code: 'await fetchData()' },
  ],
  confidence: 0.85,
};

/** Valid DocumentationSkillOutput */
const documentationSkillResponse = {
  documents: [
    { path: 'docs/api.md', content: '# API Reference\n\n...', format: 'markdown' },
  ],
  summary: 'Generated 1 documentation file',
};

/** Valid PerformanceSkillOutput */
const performanceSkillResponse = {
  findings: [
    { file: 'src/data.ts', issue: 'N+1 query', impact: 'High latency on list endpoints', suggestion: 'Batch queries' },
  ],
  overallScore: 70,
  bottlenecks: ['Database N+1 queries'],
};

/** Valid ExplorationResult (DeepWorker) */
const deepWorkerExplorationResponse = {
  relevantFiles: ['src/feature.ts', 'src/utils.ts'],
  patterns: ['Factory Pattern'],
  dependencies: ['lodash', '@/shared/utils'],
  summary: 'Workspace explored successfully',
};

/** Valid SelfPlanResult (DeepWorker) */
const selfPlanningResponse = {
  steps: [
    { id: 'step-1', description: 'Explore existing code', type: 'explore', dependencies: [], effort: 'small', completed: false },
    { id: 'step-2', description: 'Implement changes', type: 'implement', dependencies: ['step-1'], effort: 'medium', completed: false },
  ],
  summary: 'Two-step execution plan',
  totalEffort: 'medium',
};

// ============================================================================
// Keyword -> Response Mapping
// ============================================================================

interface ResponseMapping {
  keywords: string[];
  response: unknown;
}

const RESPONSE_MAP: ResponseMapping[] = [
  // DeepWorker responses (MUST be checked FIRST — most specific keywords)
  { keywords: ['code exploration specialist in an autonomous'], response: deepWorkerExplorationResponse },
  { keywords: ['planning specialist in an autonomous'], response: selfPlanningResponse },

  // Agent responses (checked BEFORE skills to prevent cross-matching)
  { keywords: ['task decomposition', 'planning expert'], response: planningResponse },
  { keywords: ['code generation', 'development agent'], response: developmentResponse },
  { keywords: ['you are the qa agent'], response: qaResponse },
  { keywords: ['architecture agent', 'component relationships'], response: architectureResponse },
  { keywords: ['you are the security agent'], response: securityResponse },
  { keywords: ['debugging agent', 'systematic root cause'], response: debuggingAgentResponse },
  { keywords: ['documentation agent', 'generating comprehensive project documentation'], response: documentationAgentResponse },
  { keywords: ['exploration agent', 'mapping codebase structure'], response: explorationResponse },
  { keywords: ['integration agent', 'component connections'], response: integrationResponse },

  // Skill responses (matched against system prompt)
  // Code Quality LLM executors (code-quality-llm.ts prompts)
  { keywords: ['expert test engineer'], response: testGenerationResponse },
  { keywords: ['senior software architect conducting deep code reviews'], response: deepReviewResponse },
  { keywords: ['refactoring expert identifying code improvement'], response: refactoringResponse },
  // Skill LLM executors (skill-llm.ts prompts)
  { keywords: ['test engineering expert in a multi-agent'], response: testGenerationResponse },
  { keywords: ['senior code reviewer in a multi-agent'], response: deepReviewResponse },
  { keywords: ['refactoring expert in a multi-agent'], response: refactoringResponse },
  { keywords: ['security analyst in a multi-agent'], response: securityScanSkillResponse },
  { keywords: ['debugging expert in a multi-agent'], response: debuggingSkillResponse },
  { keywords: ['documentation expert in a multi-agent'], response: documentationSkillResponse },
  { keywords: ['performance engineer in a multi-agent'], response: performanceSkillResponse },

  // Planning skill (uses same schema as PlanningAgent)
  { keywords: ['planning expert in a multi-agent', 'decompose a goal'], response: planningResponse },
];

// ============================================================================
// Mock LLM Client
// ============================================================================

export interface SchemaAwareMockLLMOptions {
  /** Error simulation configuration */
  errorConfig?: MockLLMErrorConfig;
}

export interface SchemaAwareMockLLM extends ILLMClient {
  /** Recorded calls for test assertions */
  calls: MockLLMCall[];
  /** Reset recorded calls */
  resetCalls(): void;
}

/**
 * Create a schema-aware mock LLM client.
 *
 * Detects agent/skill type from system prompt keywords and returns
 * JSON that passes through TeamAgentLLMAdapter.parseResponse() + Zod validation.
 */
export function createSchemaAwareMockLLM(
  options: SchemaAwareMockLLMOptions = {},
): SchemaAwareMockLLM {
  const calls: MockLLMCall[] = [];
  let callCount = 0;

  function matchResponse(messages: LLMMessage[]): unknown {
    // Check system prompt first, then all messages
    const systemPrompt = messages.find((m) => m.role === 'system')?.content?.toLowerCase() ?? '';
    const allContent = messages.map((m) => m.content.toLowerCase()).join(' ');

    for (const mapping of RESPONSE_MAP) {
      const matchesSystem = mapping.keywords.some((kw) => systemPrompt.includes(kw.toLowerCase()));
      if (matchesSystem) return mapping.response;
    }

    // Fallback: check all message content
    for (const mapping of RESPONSE_MAP) {
      const matchesAny = mapping.keywords.some((kw) => allContent.includes(kw.toLowerCase()));
      if (matchesAny) return mapping.response;
    }

    // Default fallback — generic planning response
    return planningResponse;
  }

  const mockClient: SchemaAwareMockLLM = {
    calls,

    resetCalls() {
      calls.length = 0;
      callCount = 0;
    },

    getProvider: () => 'schema-aware-mock',
    getDefaultModel: () => 'mock-model-v1',
    getMaxContextLength: () => 128000,

    async chat(
      messages: LLMMessage[],
      opts?: LLMCompletionOptions,
    ): Promise<LLMCompletionResult> {
      callCount++;

      // Record the call
      calls.push({ messages, options: opts, timestamp: Date.now() });

      // Error simulation
      const { errorConfig } = options;
      if (errorConfig?.errorOnNthCall === callCount) {
        switch (errorConfig.errorType) {
          case 'parse':
            return {
              content: 'This is not valid JSON at all {{{',
              model: 'mock-model-v1',
              usage: { promptTokens: 50, completionTokens: 10, totalTokens: 60 },
              finishReason: 'stop',
            };
          case 'timeout':
            throw new Error('LLM request timeout after 30000ms');
          case 'empty':
            return {
              content: '',
              model: 'mock-model-v1',
              usage: { promptTokens: 50, completionTokens: 0, totalTokens: 50 },
              finishReason: 'stop',
            };
          default:
            throw new Error('Mock LLM simulated error');
        }
      }

      const response = matchResponse(messages);
      const jsonString = JSON.stringify(response, null, 2);

      return {
        content: `\`\`\`json\n${jsonString}\n\`\`\``,
        model: 'mock-model-v1',
        usage: { promptTokens: 100, completionTokens: 80, totalTokens: 180 },
        finishReason: 'stop',
      };
    },

    async chatStream(
      messages: LLMMessage[],
      callback: LLMStreamCallback,
      opts?: LLMCompletionOptions,
    ): Promise<LLMCompletionResult> {
      const result = await mockClient.chat(messages, opts);
      await callback({ content: result.content, isComplete: true, usage: result.usage });
      return result;
    },
  };

  return mockClient;
}
