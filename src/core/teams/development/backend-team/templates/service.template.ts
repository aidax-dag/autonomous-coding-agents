/**
 * Service Template
 *
 * Generates service layer files.
 *
 * Feature: Team System
 */

import { TaskDocument } from '../../../team-types';
import { GeneratedFile } from '../../development-team';
import { toServiceName, toResourceName, toPascalCase } from '../utils/naming.utils';

/**
 * Generate service file
 */
export function generateServiceFile(task: TaskDocument): GeneratedFile {
  const serviceName = toServiceName(task.title);
  const resourceName = toResourceName(task.title);
  const pascalName = toPascalCase(resourceName);

  const content = `/**
 * ${serviceName}
 *
 * ${task.description}
 *
 * @generated by Backend Team
 */

import { ${pascalName}Repository, Prisma${pascalName}Repository } from '../repositories/${resourceName}.repository';

export class ${serviceName} {
  private repository: ${pascalName}Repository;

  constructor(repository?: ${pascalName}Repository) {
    this.repository = repository || new Prisma${pascalName}Repository();
  }

  async findAll(options?: { page?: number; limit?: number }) {
    const page = options?.page || 1;
    const limit = options?.limit || 20;
    const skip = (page - 1) * limit;

    const [data, total] = await Promise.all([
      this.repository.findAll({ skip, take: limit }),
      this.repository.count(),
    ]);

    return {
      data,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string) {
    const result = await this.repository.findById(id);

    if (!result) {
      throw new Error('Not found');
    }

    return result;
  }

  async create(data: unknown) {
    return this.repository.create(data as Parameters<${pascalName}Repository['create']>[0]);
  }

  async update(id: string, data: unknown) {
    await this.findById(id); // Ensure exists
    return this.repository.update(id, data as Parameters<${pascalName}Repository['update']>[1]);
  }

  async delete(id: string) {
    await this.findById(id); // Ensure exists
    await this.repository.delete(id);
  }
}

export const ${resourceName}Service = new ${serviceName}();
`;

  return {
    path: `src/services/${resourceName}.service.ts`,
    content,
    language: 'typescript',
    linesOfCode: content.split('\n').length,
    isTest: false,
  };
}

/**
 * Generate service interface file
 */
export function generateServiceInterface(task: TaskDocument): GeneratedFile {
  const serviceName = toServiceName(task.title);
  const resourceName = toResourceName(task.title);
  const typeName = toPascalCase(resourceName);

  const content = `/**
 * ${serviceName} Interface
 *
 * @generated by Backend Team
 */

export interface I${serviceName} {
  findAll(options?: { page?: number; limit?: number }): Promise<{
    data: ${typeName}[];
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  }>;

  findById(id: string): Promise<${typeName}>;

  create(data: Create${typeName}Input): Promise<${typeName}>;

  update(id: string, data: Update${typeName}Input): Promise<${typeName}>;

  delete(id: string): Promise<void>;
}

// These types should be imported from your types file
interface ${typeName} {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface Create${typeName}Input {}

interface Update${typeName}Input {}
`;

  return {
    path: `src/services/${resourceName}.service.interface.ts`,
    content,
    language: 'typescript',
    linesOfCode: content.split('\n').length,
    isTest: false,
  };
}
