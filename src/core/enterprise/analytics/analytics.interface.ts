/**
 * Usage Analytics Interfaces
 *
 * Feature: F5.13 - Usage Analytics
 * Provides usage tracking, analytics aggregation, and reporting
 *
 * @module core/enterprise/analytics
 */

import type { IDisposable } from '../../di/interfaces/container.interface.js';

/**
 * Usage metric type
 */
export type MetricType =
  | 'api_calls'
  | 'agent_hours'
  | 'workflow_runs'
  | 'storage_bytes'
  | 'token_usage'
  | 'model_calls'
  | 'team_members'
  | 'projects'
  | 'repositories';

/**
 * Aggregation period
 */
export type AggregationPeriod = 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';

/**
 * Alert severity
 */
export type AlertSeverity = 'info' | 'warning' | 'critical';

/**
 * Alert status
 */
export type AlertStatus = 'active' | 'acknowledged' | 'resolved';

/**
 * Usage record
 */
export interface UsageRecord {
  /** Record unique identifier */
  id: string;
  /** Team ID */
  teamId: string;
  /** User ID (optional) */
  userId?: string;
  /** Metric type */
  metricType: MetricType;
  /** Metric value */
  value: number;
  /** Unit of measurement */
  unit: string;
  /** Timestamp */
  timestamp: Date;
  /** Additional metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Aggregated usage data
 */
export interface AggregatedUsage {
  /** Team ID */
  teamId: string;
  /** Metric type */
  metricType: MetricType;
  /** Aggregation period */
  period: AggregationPeriod;
  /** Period start */
  periodStart: Date;
  /** Period end */
  periodEnd: Date;
  /** Total value */
  total: number;
  /** Average value */
  average: number;
  /** Minimum value */
  min: number;
  /** Maximum value */
  max: number;
  /** Sample count */
  count: number;
  /** Unit of measurement */
  unit: string;
}

/**
 * Usage summary for a team
 */
export interface UsageSummary {
  /** Team ID */
  teamId: string;
  /** Period */
  period: AggregationPeriod;
  /** Period start */
  periodStart: Date;
  /** Period end */
  periodEnd: Date;
  /** Metrics summary */
  metrics: {
    apiCalls: MetricSummary;
    agentHours: MetricSummary;
    workflowRuns: MetricSummary;
    storageBytes: MetricSummary;
    tokenUsage: MetricSummary;
    modelCalls: MetricSummary;
  };
  /** Cost estimate */
  estimatedCost: number;
  /** Currency */
  currency: string;
  /** Generated at */
  generatedAt: Date;
}

/**
 * Summary for a single metric
 */
export interface MetricSummary {
  /** Current period value */
  current: number;
  /** Previous period value */
  previous: number;
  /** Change percentage */
  changePercent: number;
  /** Trend direction */
  trend: 'up' | 'down' | 'stable';
  /** Unit */
  unit: string;
  /** Quota limit (if applicable) */
  limit?: number;
  /** Usage percentage of limit */
  usagePercent?: number;
}

/**
 * Usage report
 */
export interface UsageReport {
  /** Report unique identifier */
  id: string;
  /** Report name */
  name: string;
  /** Report type */
  type: ReportType;
  /** Team ID */
  teamId: string;
  /** Period */
  period: AggregationPeriod;
  /** Period start */
  periodStart: Date;
  /** Period end */
  periodEnd: Date;
  /** Report data */
  data: ReportData;
  /** Report format */
  format: ReportFormat;
  /** Generated at */
  generatedAt: Date;
  /** Generated by */
  generatedBy?: string;
}

/**
 * Report type
 */
export type ReportType =
  | 'usage_summary'
  | 'cost_analysis'
  | 'team_activity'
  | 'user_activity'
  | 'workflow_metrics'
  | 'resource_utilization'
  | 'trend_analysis'
  | 'custom';

/**
 * Report format
 */
export type ReportFormat = 'json' | 'csv' | 'html' | 'pdf';

/**
 * Report data
 */
export interface ReportData {
  /** Summary section */
  summary: Record<string, unknown>;
  /** Detailed sections */
  sections: ReportSection[];
  /** Charts data */
  charts?: ChartData[];
  /** Tables */
  tables?: TableData[];
}

/**
 * Report section
 */
export interface ReportSection {
  /** Section title */
  title: string;
  /** Section content */
  content: unknown;
  /** Section type */
  type: 'text' | 'chart' | 'table' | 'metric';
}

/**
 * Chart data
 */
export interface ChartData {
  /** Chart title */
  title: string;
  /** Chart type */
  type: 'line' | 'bar' | 'pie' | 'area' | 'scatter';
  /** Data series */
  series: ChartSeries[];
  /** X-axis label */
  xAxisLabel?: string;
  /** Y-axis label */
  yAxisLabel?: string;
}

/**
 * Chart series
 */
export interface ChartSeries {
  /** Series name */
  name: string;
  /** Data points */
  data: { x: string | number; y: number }[];
  /** Series color */
  color?: string;
}

/**
 * Table data
 */
export interface TableData {
  /** Table title */
  title: string;
  /** Column headers */
  headers: string[];
  /** Table rows */
  rows: unknown[][];
}

/**
 * Usage alert
 */
export interface UsageAlert {
  /** Alert unique identifier */
  id: string;
  /** Team ID */
  teamId: string;
  /** Alert type */
  type: AlertType;
  /** Severity */
  severity: AlertSeverity;
  /** Status */
  status: AlertStatus;
  /** Alert message */
  message: string;
  /** Metric type */
  metricType: MetricType;
  /** Current value */
  currentValue: number;
  /** Threshold value */
  thresholdValue: number;
  /** Unit */
  unit: string;
  /** Created at */
  createdAt: Date;
  /** Acknowledged at */
  acknowledgedAt?: Date;
  /** Acknowledged by */
  acknowledgedBy?: string;
  /** Resolved at */
  resolvedAt?: Date;
}

/**
 * Alert type
 */
export type AlertType =
  | 'quota_warning'
  | 'quota_exceeded'
  | 'usage_spike'
  | 'cost_threshold'
  | 'anomaly_detected';

/**
 * Alert rule
 */
export interface AlertRule {
  /** Rule unique identifier */
  id: string;
  /** Rule name */
  name: string;
  /** Team ID */
  teamId?: string;
  /** Metric type */
  metricType: MetricType;
  /** Alert type */
  alertType: AlertType;
  /** Condition */
  condition: AlertCondition;
  /** Severity */
  severity: AlertSeverity;
  /** Notification channels */
  notificationChannels: string[];
  /** Whether rule is enabled */
  enabled: boolean;
  /** Created at */
  createdAt: Date;
  /** Updated at */
  updatedAt: Date;
}

/**
 * Alert condition
 */
export interface AlertCondition {
  /** Operator */
  operator: '>' | '<' | '>=' | '<=' | '==' | 'spike' | 'anomaly';
  /** Threshold value */
  threshold: number;
  /** Time window in minutes (for rate-based conditions) */
  timeWindow?: number;
  /** Consecutive occurrences before alert */
  consecutiveOccurrences?: number;
}

/**
 * Cost estimate
 */
export interface CostEstimate {
  /** Team ID */
  teamId: string;
  /** Period */
  period: AggregationPeriod;
  /** Period start */
  periodStart: Date;
  /** Period end */
  periodEnd: Date;
  /** Line items */
  lineItems: CostLineItem[];
  /** Subtotal */
  subtotal: number;
  /** Discounts */
  discounts: number;
  /** Total */
  total: number;
  /** Currency */
  currency: string;
  /** Calculated at */
  calculatedAt: Date;
}

/**
 * Cost line item
 */
export interface CostLineItem {
  /** Description */
  description: string;
  /** Metric type */
  metricType: MetricType;
  /** Quantity */
  quantity: number;
  /** Unit */
  unit: string;
  /** Unit price */
  unitPrice: number;
  /** Total price */
  totalPrice: number;
}

/**
 * Analytics event
 */
export interface AnalyticsEvent {
  /** Event type */
  type: AnalyticsEventType;
  /** Team ID */
  teamId?: string;
  /** Event data */
  data: Record<string, unknown>;
  /** Event timestamp */
  timestamp: Date;
}

/**
 * Analytics event types
 */
export type AnalyticsEventType =
  | 'usage.recorded'
  | 'usage.aggregated'
  | 'alert.created'
  | 'alert.acknowledged'
  | 'alert.resolved'
  | 'report.generated'
  | 'threshold.exceeded';

/**
 * Record usage request
 */
export interface RecordUsageRequest {
  /** Team ID */
  teamId: string;
  /** User ID */
  userId?: string;
  /** Metric type */
  metricType: MetricType;
  /** Value */
  value: number;
  /** Unit */
  unit?: string;
  /** Metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Query usage request
 */
export interface QueryUsageRequest {
  /** Team ID */
  teamId: string;
  /** Metric types */
  metricTypes?: MetricType[];
  /** Start date */
  startDate: Date;
  /** End date */
  endDate: Date;
  /** User ID filter */
  userId?: string;
  /** Aggregation period */
  aggregation?: AggregationPeriod;
}

/**
 * Generate report request
 */
export interface GenerateReportRequest {
  /** Team ID */
  teamId: string;
  /** Report type */
  type: ReportType;
  /** Report name */
  name?: string;
  /** Period */
  period: AggregationPeriod;
  /** Period start */
  periodStart: Date;
  /** Period end */
  periodEnd: Date;
  /** Format */
  format?: ReportFormat;
  /** Include charts */
  includeCharts?: boolean;
  /** Custom options */
  options?: Record<string, unknown>;
}

/**
 * Create alert rule request
 */
export interface CreateAlertRuleRequest {
  /** Rule name */
  name: string;
  /** Team ID */
  teamId?: string;
  /** Metric type */
  metricType: MetricType;
  /** Alert type */
  alertType: AlertType;
  /** Condition */
  condition: AlertCondition;
  /** Severity */
  severity: AlertSeverity;
  /** Notification channels */
  notificationChannels?: string[];
}

/**
 * Usage Analytics Manager interface
 */
export interface IUsageAnalyticsManager extends IDisposable {
  // ==================== Usage Tracking ====================

  /**
   * Record a usage metric
   * @param request Record request
   */
  recordUsage(request: RecordUsageRequest): Promise<UsageRecord>;

  /**
   * Record multiple usage metrics
   * @param requests Record requests
   */
  recordUsageBatch(requests: RecordUsageRequest[]): Promise<UsageRecord[]>;

  /**
   * Query usage records
   * @param request Query request
   */
  queryUsage(request: QueryUsageRequest): Promise<UsageRecord[]>;

  /**
   * Get aggregated usage
   * @param request Query request
   */
  getAggregatedUsage(request: QueryUsageRequest): Promise<AggregatedUsage[]>;

  /**
   * Get usage summary for a team
   * @param teamId Team identifier
   * @param period Aggregation period
   */
  getUsageSummary(teamId: string, period: AggregationPeriod): Promise<UsageSummary>;

  // ==================== Reports ====================

  /**
   * Generate a usage report
   * @param request Generate request
   */
  generateReport(request: GenerateReportRequest): Promise<UsageReport>;

  /**
   * Get a report by ID
   * @param reportId Report identifier
   */
  getReport(reportId: string): Promise<UsageReport | undefined>;

  /**
   * Get reports for a team
   * @param teamId Team identifier
   * @param limit Maximum reports to return
   */
  getReports(teamId: string, limit?: number): Promise<UsageReport[]>;

  /**
   * Delete a report
   * @param reportId Report identifier
   */
  deleteReport(reportId: string): Promise<boolean>;

  // ==================== Cost Analysis ====================

  /**
   * Get cost estimate for a team
   * @param teamId Team identifier
   * @param period Aggregation period
   */
  getCostEstimate(teamId: string, period: AggregationPeriod): Promise<CostEstimate>;

  /**
   * Get cost trends
   * @param teamId Team identifier
   * @param periods Number of periods to include
   * @param period Aggregation period
   */
  getCostTrends(teamId: string, periods: number, period: AggregationPeriod): Promise<CostEstimate[]>;

  // ==================== Alerts ====================

  /**
   * Create an alert rule
   * @param request Create request
   */
  createAlertRule(request: CreateAlertRuleRequest): Promise<AlertRule>;

  /**
   * Get alert rule by ID
   * @param ruleId Rule identifier
   */
  getAlertRule(ruleId: string): Promise<AlertRule | undefined>;

  /**
   * Update an alert rule
   * @param ruleId Rule identifier
   * @param updates Partial rule updates
   */
  updateAlertRule(ruleId: string, updates: Partial<AlertRule>): Promise<AlertRule>;

  /**
   * Delete an alert rule
   * @param ruleId Rule identifier
   */
  deleteAlertRule(ruleId: string): Promise<boolean>;

  /**
   * Get all alert rules
   * @param teamId Optional team filter
   */
  getAlertRules(teamId?: string): Promise<AlertRule[]>;

  /**
   * Get active alerts
   * @param teamId Optional team filter
   */
  getActiveAlerts(teamId?: string): Promise<UsageAlert[]>;

  /**
   * Acknowledge an alert
   * @param alertId Alert identifier
   * @param acknowledgedBy User ID
   */
  acknowledgeAlert(alertId: string, acknowledgedBy: string): Promise<UsageAlert>;

  /**
   * Resolve an alert
   * @param alertId Alert identifier
   */
  resolveAlert(alertId: string): Promise<UsageAlert>;

  /**
   * Get alert history
   * @param teamId Team identifier
   * @param limit Maximum alerts to return
   */
  getAlertHistory(teamId: string, limit?: number): Promise<UsageAlert[]>;

  // ==================== Real-time Metrics ====================

  /**
   * Get current metric values
   * @param teamId Team identifier
   * @param metricTypes Metric types to get
   */
  getCurrentMetrics(teamId: string, metricTypes: MetricType[]): Promise<Map<MetricType, number>>;

  /**
   * Get metric time series
   * @param teamId Team identifier
   * @param metricType Metric type
   * @param startDate Start date
   * @param endDate End date
   * @param granularity Data point granularity
   */
  getMetricTimeSeries(
    teamId: string,
    metricType: MetricType,
    startDate: Date,
    endDate: Date,
    granularity: AggregationPeriod
  ): Promise<{ timestamp: Date; value: number }[]>;

  // ==================== Events ====================

  /**
   * Subscribe to analytics events
   * @param handler Event handler
   */
  onAnalyticsEvent(handler: (event: AnalyticsEvent) => void): () => void;
}

/**
 * Default pricing (per unit)
 */
export const DEFAULT_PRICING: Record<MetricType, { price: number; unit: string }> = {
  api_calls: { price: 0.001, unit: 'call' },
  agent_hours: { price: 5.0, unit: 'hour' },
  workflow_runs: { price: 0.01, unit: 'run' },
  storage_bytes: { price: 0.00000001, unit: 'byte' }, // $0.01 per GB
  token_usage: { price: 0.00001, unit: 'token' },
  model_calls: { price: 0.01, unit: 'call' },
  team_members: { price: 0, unit: 'member' },
  projects: { price: 0, unit: 'project' },
  repositories: { price: 0, unit: 'repo' },
};

/**
 * Default units for metrics
 */
export const DEFAULT_METRIC_UNITS: Record<MetricType, string> = {
  api_calls: 'calls',
  agent_hours: 'hours',
  workflow_runs: 'runs',
  storage_bytes: 'bytes',
  token_usage: 'tokens',
  model_calls: 'calls',
  team_members: 'members',
  projects: 'projects',
  repositories: 'repos',
};
