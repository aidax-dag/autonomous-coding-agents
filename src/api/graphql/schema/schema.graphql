# GraphQL Schema for Autonomous Coding Agents
#
# Feature: F4.3 - GraphQL API
#
# This schema defines the GraphQL API for managing agents, workflows, tasks,
# tools, and hooks in the autonomous coding agents system.

# ==================== Scalars ====================

scalar DateTime
scalar JSON

# ==================== Enums ====================

enum AgentStatus {
  IDLE
  RUNNING
  PAUSED
  STOPPED
  ERROR
}

enum WorkflowStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  PAUSED
}

enum TaskStatus {
  PENDING
  QUEUED
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum ToolType {
  BUILTIN
  CUSTOM
  MCP
  EXTERNAL
}

enum HookTrigger {
  BEFORE
  AFTER
  ON_ERROR
  ON_SUCCESS
}

enum SortOrder {
  ASC
  DESC
}

enum HealthStatus {
  healthy
  degraded
  unhealthy
}

# ==================== Input Types ====================

input PaginationInput {
  page: Int = 1
  limit: Int = 20
  offset: Int
}

input SortInput {
  field: String!
  order: SortOrder = DESC
}

input DateRangeInput {
  from: DateTime
  to: DateTime
}

input AgentFilterInput {
  status: [AgentStatus!]
  type: [String!]
  createdAt: DateRangeInput
  search: String
}

input WorkflowFilterInput {
  status: [WorkflowStatus!]
  agentId: ID
  createdAt: DateRangeInput
  search: String
}

input TaskFilterInput {
  status: [TaskStatus!]
  workflowId: ID
  agentId: ID
  createdAt: DateRangeInput
  search: String
}

input ToolFilterInput {
  type: [ToolType!]
  enabled: Boolean
  search: String
}

input HookFilterInput {
  trigger: [HookTrigger!]
  targetType: String
  enabled: Boolean
  search: String
}

input CreateAgentInput {
  name: String!
  type: String!
  description: String
  config: JSON
  tools: [ID!]
  hooks: [ID!]
}

input UpdateAgentInput {
  name: String
  description: String
  config: JSON
  tools: [ID!]
  hooks: [ID!]
}

input CreateWorkflowInput {
  name: String!
  description: String
  agentId: ID!
  steps: [WorkflowStepInput!]!
  config: JSON
}

input WorkflowStepInput {
  name: String!
  type: String!
  config: JSON
  dependencies: [String!]
}

input UpdateWorkflowInput {
  name: String
  description: String
  steps: [WorkflowStepInput!]
  config: JSON
}

input ExecuteToolInput {
  toolId: ID!
  params: JSON
  context: JSON
}

input CreateHookInput {
  name: String!
  trigger: HookTrigger!
  targetType: String!
  targetId: ID
  handler: String!
  config: JSON
  enabled: Boolean = true
}

input UpdateHookInput {
  name: String
  handler: String
  config: JSON
  enabled: Boolean
}

input CreateTaskInput {
  name: String!
  workflowId: ID
  agentId: ID
  input: JSON
}

# ==================== Output Types ====================

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
  totalCount: Int!
  totalPages: Int!
  currentPage: Int!
}

type Agent {
  id: ID!
  name: String!
  type: String!
  description: String
  status: AgentStatus!
  config: JSON
  tools: [Tool!]!
  hooks: [Hook!]!
  workflows: [Workflow!]!
  tasks: [Task!]!
  metrics: AgentMetrics
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AgentMetrics {
  tasksCompleted: Int!
  tasksFailed: Int!
  averageExecutionTime: Float!
  uptime: Float!
  lastActiveAt: DateTime
}

type AgentEdge {
  node: Agent!
  cursor: String!
}

type AgentConnection {
  edges: [AgentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Workflow {
  id: ID!
  name: String!
  description: String
  status: WorkflowStatus!
  agent: Agent!
  steps: [WorkflowStep!]!
  tasks: [Task!]!
  config: JSON
  progress: Float
  result: JSON
  error: String
  startedAt: DateTime
  completedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type WorkflowStep {
  id: ID!
  name: String!
  type: String!
  status: TaskStatus!
  config: JSON
  dependencies: [String!]!
  result: JSON
  error: String
  startedAt: DateTime
  completedAt: DateTime
}

type WorkflowEdge {
  node: Workflow!
  cursor: String!
}

type WorkflowConnection {
  edges: [WorkflowEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Task {
  id: ID!
  name: String!
  status: TaskStatus!
  workflow: Workflow
  agent: Agent
  input: JSON
  output: JSON
  error: String
  progress: Float
  startedAt: DateTime
  completedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TaskEdge {
  node: Task!
  cursor: String!
}

type TaskConnection {
  edges: [TaskEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Tool {
  id: ID!
  name: String!
  type: ToolType!
  description: String
  version: String
  schema: JSON
  config: JSON
  enabled: Boolean!
  executionCount: Int!
  lastExecutedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ToolEdge {
  node: Tool!
  cursor: String!
}

type ToolConnection {
  edges: [ToolEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ToolResult {
  success: Boolean!
  result: JSON
  error: String
  executionTime: Float!
  timestamp: DateTime!
}

type Hook {
  id: ID!
  name: String!
  trigger: HookTrigger!
  targetType: String!
  targetId: ID
  handler: String!
  config: JSON
  enabled: Boolean!
  executionCount: Int!
  lastExecutedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HookEdge {
  node: Hook!
  cursor: String!
}

type HookConnection {
  edges: [HookEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SystemMetrics {
  agents: ResourceMetrics!
  workflows: ResourceMetrics!
  tasks: ResourceMetrics!
  tools: ResourceMetrics!
  hooks: ResourceMetrics!
  system: SystemResourceMetrics!
}

type ResourceMetrics {
  total: Int!
  active: Int!
  completed: Int
  failed: Int
}

type SystemResourceMetrics {
  uptime: Float!
  memoryUsage: Float!
  cpuUsage: Float!
  requestsPerSecond: Float!
  averageResponseTime: Float!
}

type HealthStatus {
  status: HealthStatus!
  version: String!
  uptime: Float!
  timestamp: DateTime!
  services: [ServiceHealth!]!
}

type ServiceHealth {
  name: String!
  status: HealthStatus!
  latency: Float
  message: String
}

type MutationResult {
  success: Boolean!
  message: String
}

# ==================== Query Type ====================

type Query {
  # Agent queries
  agent(id: ID!): Agent
  agents(
    filter: AgentFilterInput
    sort: SortInput
    pagination: PaginationInput
  ): AgentConnection!
  agentByName(name: String!): Agent

  # Workflow queries
  workflow(id: ID!): Workflow
  workflows(
    filter: WorkflowFilterInput
    sort: SortInput
    pagination: PaginationInput
  ): WorkflowConnection!
  workflowsByAgent(agentId: ID!, pagination: PaginationInput): WorkflowConnection!

  # Task queries
  task(id: ID!): Task
  tasks(
    filter: TaskFilterInput
    sort: SortInput
    pagination: PaginationInput
  ): TaskConnection!
  tasksByWorkflow(workflowId: ID!, pagination: PaginationInput): TaskConnection!
  tasksByAgent(agentId: ID!, pagination: PaginationInput): TaskConnection!

  # Tool queries
  tool(id: ID!): Tool
  tools(
    filter: ToolFilterInput
    sort: SortInput
    pagination: PaginationInput
  ): ToolConnection!
  toolByName(name: String!): Tool

  # Hook queries
  hook(id: ID!): Hook
  hooks(
    filter: HookFilterInput
    sort: SortInput
    pagination: PaginationInput
  ): HookConnection!
  hooksByTarget(targetType: String!, targetId: ID): HookConnection!

  # System queries
  metrics: SystemMetrics!
  health: HealthStatus!
}

# ==================== Mutation Type ====================

type Mutation {
  # Agent mutations
  createAgent(input: CreateAgentInput!): Agent!
  updateAgent(id: ID!, input: UpdateAgentInput!): Agent!
  deleteAgent(id: ID!): MutationResult!
  startAgent(id: ID!): Agent!
  stopAgent(id: ID!): Agent!
  pauseAgent(id: ID!): Agent!
  resumeAgent(id: ID!): Agent!

  # Workflow mutations
  createWorkflow(input: CreateWorkflowInput!): Workflow!
  updateWorkflow(id: ID!, input: UpdateWorkflowInput!): Workflow!
  deleteWorkflow(id: ID!): MutationResult!
  startWorkflow(id: ID!): Workflow!
  stopWorkflow(id: ID!): Workflow!
  pauseWorkflow(id: ID!): Workflow!
  resumeWorkflow(id: ID!): Workflow!
  retryWorkflow(id: ID!): Workflow!

  # Task mutations
  createTask(input: CreateTaskInput!): Task!
  cancelTask(id: ID!): Task!
  retryTask(id: ID!): Task!

  # Tool mutations
  executeTool(input: ExecuteToolInput!): ToolResult!
  enableTool(id: ID!): Tool!
  disableTool(id: ID!): Tool!

  # Hook mutations
  createHook(input: CreateHookInput!): Hook!
  updateHook(id: ID!, input: UpdateHookInput!): Hook!
  deleteHook(id: ID!): MutationResult!
  enableHook(id: ID!): Hook!
  disableHook(id: ID!): Hook!
  triggerHook(id: ID!, payload: JSON): MutationResult!
}

# ==================== Subscription Type ====================

type Subscription {
  # Agent subscriptions
  agentCreated: Agent!
  agentUpdated(id: ID): Agent!
  agentDeleted: ID!
  agentStatusChanged(id: ID): AgentStatusChange!

  # Workflow subscriptions
  workflowCreated(agentId: ID): Workflow!
  workflowUpdated(id: ID): Workflow!
  workflowCompleted(id: ID): Workflow!
  workflowFailed(id: ID): Workflow!
  workflowProgress(id: ID!): WorkflowProgress!

  # Task subscriptions
  taskCreated(workflowId: ID, agentId: ID): Task!
  taskUpdated(id: ID): Task!
  taskCompleted(id: ID): Task!
  taskFailed(id: ID): Task!
  taskProgress(id: ID!): TaskProgress!

  # Tool subscriptions
  toolExecuted(id: ID): ToolExecution!

  # Hook subscriptions
  hookTriggered(id: ID, targetType: String): HookExecution!

  # System subscriptions
  metricsUpdated: SystemMetrics!
}

# ==================== Subscription Payload Types ====================

type AgentStatusChange {
  agent: Agent!
  previousStatus: AgentStatus!
  newStatus: AgentStatus!
  timestamp: DateTime!
}

type WorkflowProgress {
  workflow: Workflow!
  progress: Float!
  currentStep: WorkflowStep
  timestamp: DateTime!
}

type TaskProgress {
  task: Task!
  progress: Float!
  message: String
  timestamp: DateTime!
}

type ToolExecution {
  tool: Tool!
  result: ToolResult!
  agentId: ID
  timestamp: DateTime!
}

type HookExecution {
  hook: Hook!
  success: Boolean!
  error: String
  payload: JSON
  timestamp: DateTime!
}
